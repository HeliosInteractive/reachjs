(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("form-data"), require("url"), require("https"), require("http"), (function webpackLoadOptionalExternalModule() { try { return require("fs"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define("reach", ["form-data", "url", "https", "http", "fs"], factory);
	else if(typeof exports === 'object')
		exports["reach"] = factory(require("form-data"), require("url"), require("https"), require("http"), (function webpackLoadOptionalExternalModule() { try { return require("fs"); } catch(e) {} }()));
	else
		root["reach"] = factory(root["form-data"], root["url"], root["https"], root["http"], root["fs"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/*!
 * @name JavaScript/NodeJS Merge v1.2.0
 * @author yeikos
 * @repository https://github.com/yeikos/js.merge

 * Copyright 2014 yeikos - MIT license
 * https://raw.github.com/yeikos/js.merge/master/LICENSE
 */

;(function(isNode) {

	/**
	 * Merge one or more objects 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	var Public = function(clone) {

		return merge(clone === true, false, arguments);

	}, publicName = 'merge';

	/**
	 * Merge two or more objects recursively 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	Public.recursive = function(clone) {

		return merge(clone === true, true, arguments);

	};

	/**
	 * Clone the input removing any reference
	 * @param mixed input
	 * @return mixed
	 */

	Public.clone = function(input) {

		var output = input,
			type = typeOf(input),
			index, size;

		if (type === 'array') {

			output = [];
			size = input.length;

			for (index=0;index<size;++index)

				output[index] = Public.clone(input[index]);

		} else if (type === 'object') {

			output = {};

			for (index in input)

				output[index] = Public.clone(input[index]);

		}

		return output;

	};

	/**
	 * Merge two objects recursively
	 * @param mixed input
	 * @param mixed extend
	 * @return mixed
	 */

	function merge_recursive(base, extend) {

		if (typeOf(base) !== 'object')

			return extend;

		for (var key in extend) {

			if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {

				base[key] = merge_recursive(base[key], extend[key]);

			} else {

				base[key] = extend[key];

			}

		}

		return base;

	}

	/**
	 * Merge two or more objects
	 * @param bool clone
	 * @param bool recursive
	 * @param array argv
	 * @return object
	 */

	function merge(clone, recursive, argv) {

		var result = argv[0],
			size = argv.length;

		if (clone || typeOf(result) !== 'object')

			result = {};

		for (var index=0;index<size;++index) {

			var item = argv[index],

				type = typeOf(item);

			if (type !== 'object') continue;

			for (var key in item) {

				var sitem = clone ? Public.clone(item[key]) : item[key];

				if (recursive) {

					result[key] = merge_recursive(result[key], sitem);

				} else {

					result[key] = sitem;

				}

			}

		}

		return result;

	}

	/**
	 * Get type of variable
	 * @param mixed input
	 * @return string
	 *
	 * @see http://jsperf.com/typeofvar
	 */

	function typeOf(input) {

		return ({}).toString.call(input).slice(8, -1).toLowerCase();

	}

	if (isNode) {

		module.exports = Public;

	} else {

		window[publicName] = Public;

	}

})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _merge = __webpack_require__(0);

var _merge2 = _interopRequireDefault(_merge);

var _request = __webpack_require__(3);

var _request2 = _interopRequireDefault(_request);

var _image = __webpack_require__(8);

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var internalUrl = void 0;

/**
 * No op to get around jshint empty catch statement warnings
 */
function noop() {}

/**
 * Format request options data
 * @param options
 * @returns {*}
 */
function formatData(options) {
  if (options.method !== 'POST' && options.method !== 'PUT') {
    return options;
  }

  if (options.headers && options.headers['Content-Type'] === 'multipart/form-data') {
    return options;
  }

  var copy = (0, _merge2.default)(options);
  var data = (0, _merge2.default)(true, options);
  delete data.headers;
  delete data.uri;
  delete data.data;
  delete data.method;
  copy.data = data;

  return copy;
}

/**
 * Turn options arguments into loopback filter string
 * @param fil
 * @param options
 * @returns {boolean}
 */
function filter(fil, options) {
  var query = (0, _merge2.default)(fil);
  if (options.where) {
    query.where = options.where;
  }
  if (options.limit) {
    query.limit = options.limit;
  }
  if (options.include) {
    query.include = options.include;
  }
  if (options.skip) {
    query.skip = options.skip;
  }
  if (options.fields) {
    query.fields = options.fields;
  }
  if (options.order) {
    query.order = options.order;
  }

  var qs = false;
  // the options are just a query filter
  if (Object.keys(query).length > 0) {
    try {
      qs = JSON.stringify(query);
    } catch (e) {
      noop();
    }
  }
  return qs;
}

/**
 * Make HTTP requests to reach
 * @param {string|options} url
 * @param {object|function} data
 * @param {string} options.uri
 * @param {object} options.headers
 * @param {string} options.qs
 * @callback callback
 * @returns {*}
 */
var reach = function reach(url, data, callback) {
  if (!internalUrl) {
    throw new Error('set the url for reach with reachjs.setUrl()');
  }
  if (typeof url === 'undefined') {
    throw new Error('undefined is not a valid url or options object.');
  }
  if (!reach.key && data.qs && !data.qs.access_token) {
    throw new Error('reach.key or token is required');
  }
  var done = callback;
  var options = data;
  var uri = url;

  if (typeof options === 'function') {
    done = options;
  }

  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    options.uri = uri;
  } else if (typeof uri === 'string') {
    options = { uri: uri };
  } else {
    options = uri;
  }

  if (options.uri.substr(0, 1) === '/') {
    options.uri = options.uri.substr(1);
  }
  options = formatData(options);

  uri = internalUrl + options.uri;
  delete options.uri;

  var qs = filter({}, options);
  if (!options.qs) {
    options.qs = {};
  }
  if (qs) {
    options.qs.filter = qs;
  }
  if (!options.headers) {
    options.headers = {};
  }
  if (reach.key && !options.headers['X-Helios-ID']) {
    options.headers['X-Helios-ID'] = reach.key;
  }

  if (!options.headers['Content-Type']) {
    options.headers['Content-Type'] = 'application/json';
  }

  return new _request2.default(uri, options, done);
};
/**
 * Shortcut methods for HTTP verbs
 * @param verb
 * @returns {Function}
 */
function verbFunc(method) {
  return function verbFuncInternal(url, data, callback) {
    var uri = url;
    var done = callback;
    var options = data;
    if (typeof options === 'function') {
      done = options;
      options = {};
    }
    if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
      uri.method = method;
    } else {
      options.method = method;
    }
    return reach(uri, options, done);
  };
}

function upload(activationId, file, args, callback) {
  var data = file;
  var options = args;
  var done = callback;
  if (typeof options === 'function') {
    done = options;
    options = {};
  }

  if (data[0]) {
    data = data.map(function (o) {
      var obj = (0, _merge2.default)(true, o);
      obj.path = obj.name;
      return obj;
    });
  } else {
    data.path = data.name;
  }

  reach('files/upload/' + activationId, {
    method: 'POST',
    qs: {
      options: JSON.stringify(options)
    },
    headers: {
      'Content-Type': 'multipart/form-data'
    },
    data: data
  }, done);
}

reach.key = null;
reach.get = verbFunc('GET');
reach.post = verbFunc('POST');
reach.put = verbFunc('PUT');
reach.del = verbFunc('DELETE');
reach.request = _request2.default;
reach.image = _image2.default;
reach.upload = upload;

reach.development = function reachDevelopment() {
  throw new Error('reach.development is no longer supported. Set the url explicitly with reach.setUrl()');
};

// set your endpoint
reach.setUrl = function reachSetUrl(uri) {
  var url = uri;
  if (url.substr(-1) !== '/') {
    url = url + '/';
  }
  if (url.substr(-4) !== 'api/') {
    url = url + 'api/';
  }
  if (url) {
    internalUrl = url;
  }
};

exports.default = reach;
module.exports = exports['default'];

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _merge = __webpack_require__(0);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Request = function () {
  /**
   * Noop for catch
   */
  function noop() {}
  /**
   * Create formdata for node
   * @param data
   * @returns {FormData|exports|module.exports}
   */
  function getForm(data) {
    var FormData = __webpack_require__(4); // eslint-disable-line global-require
    var form = new FormData();
    form.append('file', data.data, {
      filename: data.path,
      contentType: data.type,
      basename: false
    });
    return form;
  }
  /**
   * Format a query string
   * @param obj
   * @returns {*}
   */
  function querystring(obj) {
    if (!obj) return '';
    if (typeof obj === 'string') return '?' + obj;

    function toParam(a, k) {
      a.push(k + '=' + encodeURIComponent(obj[k]));
      return a;
    }

    return '?' + Object.keys(obj).reduce(toParam, []).join('&');
  }
  /**
   * Split string headers into key -> value pairs
   * @param headers
   * @returns {*}
   */
  function parseHeaders(headers) {
    if (!headers) return headers;

    var h = {};

    function foreachHeader(header) {
      if (!header) return;
      var a = header.split(':');
      h[a[0]] = a[1].trim();
    }

    headers.split('\r\n').forEach(foreachHeader);

    return h;
  }
  /**
   * Browser request
   * @param opts
   * @callback done
   */
  var xhr = function xhr(base, opts, done) {
    var _this = this;

    this.oReq = new XMLHttpRequest();

    var options = (0, _merge2.default)(opts);
    var uri = '' + base + querystring(options.qs);

    function xhrError(err) {
      // TODO: standardize error format
      done(err);
    }

    var xhrResponse = function xhrResponse(res) {
      var response = {
        body: res.target.response,
        status: res.target.status,
        url: res.target.responseURL,
        headers: parseHeaders(_this.oReq.getAllResponseHeaders())
      };

      try {
        var body = JSON.parse(res.target.response);
        response.body = body;
      } catch (e) {
        noop();
      }

      done(null, response);
    };

    this.oReq.addEventListener('load', xhrResponse);
    this.oReq.addEventListener('error', xhrError);
    this.oReq.open(options.method && options.method.toUpperCase() || 'GET', uri, true);

    var data = null;

    if (options.data) {
      if (options.headers && options.headers['Content-Type'] === 'multipart/form-data') {
        data = new FormData();
        data.append('file', options.data.data, options.data.path);
        delete options.headers['Content-Type'];
      } else {
        data = JSON.stringify(options.data);
      }
    }

    if (options.headers && _typeof(options.headers) === 'object') {
      Object.keys(options.headers).forEach(this.setHeaders.bind(this, options.headers));
    }

    this.oReq.send(data);
  };
  /**
   * Convert keys of object to headers
   * @param headers
   * @param key
   */
  xhr.prototype.setHeaders = function setHeaders(headers, key) {
    this.oReq.setRequestHeader(key, headers[key]);
  };
  /**
   * Node request
   * @param opts
   * @callback done
   */
  var http = function http(base, opts, done) {
    var url = __webpack_require__(5); // eslint-disable-line global-require
    var uri = '' + base + querystring(opts.qs);
    var parsed = url.parse(uri, true, true);
    var httpMod = void 0;
    if (parsed.protocol === 'https:') {
      httpMod = __webpack_require__(6); // eslint-disable-line global-require
    } else {
      httpMod = __webpack_require__(7); // eslint-disable-line global-require
    }

    var reqOptions = {
      host: parsed.hostname,
      protocol: parsed.protocol,
      port: parsed.port,
      path: parsed.path,
      headers: opts.headers,
      method: opts.method
    };

    function httpResponse(res) {
      var response = {
        body: '',
        status: res.statusCode,
        url: uri,
        headers: res.headers
      };

      function onData(chunk) {
        response.body += chunk;
      }

      function onEnd() {
        try {
          var body = JSON.parse(response.body);
          response.body = body;
        } catch (e) {
          noop();
        }
        done(null, response);
      }

      res.setEncoding('utf8');
      res.on('data', onData);
      res.on('end', onEnd);
    }

    function httpError(err) {
      // TODO: coerce error to standard format
      done(err);
    }

    var form = false;
    if (opts.headers && opts.headers['Content-Type'] === 'multipart/form-data') {
      form = getForm(opts.data);
      reqOptions.headers['Content-Type'] = form.getHeaders()['content-type'];
    }

    var req = httpMod.request(reqOptions, httpResponse).on('error', httpError);

    if (form) {
      form.pipe(req);
    } else if (opts.data) {
      req.write(JSON.stringify(opts.data));
    }
    req.end();
  };

  if (typeof XMLHttpRequest !== 'undefined') {
    // browser
    return xhr;
  }
  return http;
}();

exports.default = Request;
module.exports = exports['default'];

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("form-data");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var image = function () {
  // jshint ignore:line
  var Image = {};
  var perf = false;

  function noop() {}

  try {
    if (window && window.performance && typeof window.performance.now === 'function') {
      perf = window.performance; // use high-precision timer if available
    }
  } catch (e) {
    noop();
  }

  Image.supportedMimeTypes = {
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.mp4': 'video/mp4',
    'image/png': '.png',
    'image/jpeg': '.jpg',
    'image/gif': '.gif',
    'video/mp4': '.mp4'
  };

  try {
    // for node webkit
    if (!HTMLCanvasElement.prototype.toBlob) {
      Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
        value: function value(done, type, quality) {
          var binStr = atob(this.toDataURL(type, quality).split(',')[1]);
          var len = binStr.length;
          var arr = new Uint8Array(len);

          for (var i = 0; i < len; i += 1) {
            arr[i] = binStr.charCodeAt(i);
          }

          done(new Blob([arr], {
            type: type || 'image/png'
          }));
        }
      });
    }
  } catch (e) {
    noop();
  }
  /**
   * Generate uuid for filenames
   * @returns {string}
   */
  function uuid() {
    var d = new Date().getTime();
    if (perf) {
      d += perf.now();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  }
  /**
   * Converts canvas to either blob or buffer if blob isn't supported
   * @param canvas
   * @param options
   * @callback done
   */
  function toBlobOrBuffer(canvas, options, done) {
    var filename = uuid() + Image.supportedMimeTypes[options.type];
    try {
      // browser
      canvas.toBlob(function (blob) {
        done(null, {
          name: filename,
          type: options.type,
          data: blob
        });
      }, options.type, options.quality);
    } catch (e) {
      // node
      setTimeout(function () {
        var regex = new RegExp('data:' + options.type + ';base64,');
        var buffer = new Buffer(canvas.toDataURL(options.type, options.quality).replace(regex, ''), 'base64');
        done(null, {
          name: filename,
          type: options.type,
          data: buffer
        });
      }, 1);
    }
  }
  /**
   * Get image buffer from html <canvas/> element
   * @param {object} canvas `document.getElementByTagName("canvas')[0];`
   * @param {object} data image options like mimetype and compression
   * @callback callback
   * @return {Buffer}
   */
  Image.fromCanvas = function fromCanvas(canvas, data, callback) {
    var done = callback;
    var options = data;
    if (typeof options === 'function') {
      done = options;
      options = 'image/png';
    }
    if (typeof options === 'string') {
      options = {
        type: options,
        quality: 1
      };
    }
    if (!options.type) options.type = 'image/png';
    if (!options.quality) options.quality = 1;

    toBlobOrBuffer(canvas, options, done);
  };
  /**
   * Get image buffer from html <img/> element
   * @param {object} img `document.getElementByTagName('img')[0];`
   * @param {object} data image options like mimetype and compression
   * @callback callback
   * @return {Buffer}
   */
  Image.fromImage = function fromImage(img, data, callback) {
    var extension = '.' + img.src.split('.').pop();
    var done = callback;
    var options = data;
    if (typeof options === 'function') {
      done = options;
      options = {
        type: Image.supportedMimeTypes[extension],
        quality: 1
      };
    }
    if (typeof options === 'string') {
      options = {
        type: options,
        quality: 1
      };
    }
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;

    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);

    Image.fromCanvas(canvas, options, done);
  };
  /**
   * Read file data to buffer from file input
   * @param {object} file input element `document.getElementByTagName('input')[0];`
   * @callback done
   * @param {object|null} error
   * @param {Buffer} data
   * @returns {*}
   */
  Image.fromFileInput = function fromFileInput(file, done) {
    Image.fromBuffer(file, file.name, done);
    return file;
  };
  /**
   * Read a local file to buffer for uploading to reach
   * @param {string} path
   * @callback done
   * @param {object|null} error
   * @param {Buffer} data
   * @returns {*}
   */
  Image.fromLocalPath = function fromLocalPath(path, done) {
    try {
      __webpack_require__(9).readFile(path, function (err, data) {
        // eslint-disable-line global-require
        Image.fromBuffer(data, path, done);
      });
    } catch (e) {
      throw new Error('reach.image.fromLocalPath only supported in node.');
    }
    return path;
  };
  /**
   * Setup data for uploads from buffer
   *
   * @param {Buffer|Blob} buffer
   * @param {string} path full path to file `path/to/folder`
   * @callback done
   */
  Image.fromBuffer = function fromBuffer(buffer, path, done) {
    setTimeout(function () {
      var extension = '.' + path.split('.').pop();
      done(null, buffer && {
        name: uuid() + extension,
        type: Image.supportedMimeTypes[extension],
        data: buffer
      });
    }, 1);
  };

  return Image;
}();

exports.default = image;
module.exports = exports['default'];

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ })
/******/ ]);
});